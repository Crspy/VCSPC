template <class T>
class CLinkVC {
public:
	void Insert(CLinkVC<T>* pAttach) {
		pAttach->m_pNext = m_pNext;
		m_pNext->m_pPrev = pAttach;
		
		pAttach->m_pPrev = this;
		m_pNext = pAttach;
	}

	void Remove(void) {
		m_pNext->m_pPrev = m_pPrev;
		m_pPrev->m_pNext = m_pNext;
	}

	T* V(void) {
		return m_pItem;
	}

	T* m_pItem; // 0-4
	//pointer to the item
	CLinkVC<T>* m_pPrev; // 4-8
	//next link in the list
	CLinkVC<T>* m_pNext; // 8-12
	//prev link in the list
};

template <class T>
class CLinkListVC {
public:
	CLinkListVC(void) {
		m_plnLinks = NULL;
	}

	void Init(int nNumLinks) {
		m_plnLinks = new CLinkVC<T>[nNumLinks];

		m_lnListHead.m_pNext = &m_lnListTail;
		m_lnListTail.m_pPrev = &m_lnListHead;

		m_lnFreeListHead.m_pNext = &m_lnFreeListTail;
		m_lnFreeListTail.m_pPrev = &m_lnFreeListHead;

		for(int i = nNumLinks - 1; i >= 0; i--) {
			m_lnFreeListHead.Insert(&m_plnLinks[i]);
		}
	}

	void Shutdown(void) {
		delete[] m_plnLinks;

		m_plnLinks = NULL;
	}

	CLinkVC<T>* InsertSorted(T* pItem) {
		CLinkVC<T>* pLink = m_lnFreeListHead.m_pNext;

		if(pLink == &m_lnFreeListTail) {
			return NULL;
		}

		pLink->m_pItem = pItem;

		pLink->Remove();

		CLinkVC<T>* pInsertAfter = &m_lnListHead;

		while(pInsertAfter->m_pNext != &m_lnListTail && *pInsertAfter->m_pNext->m_pItem < *pItem) {
			pInsertAfter = pInsertAfter->m_pNext;
		}

		pInsertAfter->Insert(pLink);

		return pLink;
	}

	CLinkVC<T>* Insert(T* pItem) {
		CLinkVC<T>* pLink = m_lnFreeListHead.m_pNext;

		if(pLink == &m_lnFreeListTail) {
			return NULL;
		}

		pLink->m_pItem = pItem;

		pLink->Remove();
		m_lnListHead.Insert(pLink);

		return pLink;
	}

	void Clear(void) {
		while(m_lnListHead.m_pNext != &m_lnListTail) {
			m_lnListHead.m_pNext->Remove();
		}
	}

	void Remove(CLinkVC<T>* pLink) {
		pLink->Remove();
		m_lnFreeListHead.Insert(pLink);
	}

	CLinkVC<T>* Next(CLinkVC<T>* pCurrent) {
		if(pCurrent == 0) {
			pCurrent = &m_lnListHead;
		}

		if(pCurrent->m_pNext == &m_lnListTail) {
			return 0;
		}
		else {
			return pCurrent->m_pNext;
		}
	}

	CLinkVC<T> m_lnListHead; // 0-12
	//head of the list of active links
	CLinkVC<T> m_lnListTail; // 12-24
	//tail of the list of active links
	CLinkVC<T> m_lnFreeListHead; // 24-36
	//head of the list of free links
	CLinkVC<T> m_lnFreeListTail; // 36-48
	//tail of the list of free links
	CLinkVC<T>* m_plnLinks; // 48-52
	//pointer to actual array of links
};